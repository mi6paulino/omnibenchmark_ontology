# from https://github.com/omnibenchmark/omniSparql/blob/main/src/omniSparql/sparql.py

# from https://gitlab.renkulab.io/btraven/omni-cli/-/blob/main/omni_cli/sparql.py

# provenanceForLastEpoch
PREFIX schema: <http://schema.org/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX renku: <https://swissdatasciencecenter.github.io/renku-ontology#>

SELECT DISTINCT ?act ?kw ?ended ?inputfile ?outputfile WHERE {

  # get the generation for the activity, and descend into
  # the keywords to identify the project that generated it
  ?gen prov:activity ?act .
  ?entity prov:qualifiedGeneration ?gen .
  ?files prov:entity ?entity .
  ?dataset schema:hasPart ?files .
  ?dataset schema:keywords ?kw .

  ?act a prov:Activity .
  ?act prov:qualifiedAssociation ?asoc.
  ?asoc prov:hadPlan ?plan .
  ?plan renku:hasInputs ?input .
  ?input schema:defaultValue ?inputfile .

  # handy heuristic: we do not care about src/*
  FILTER (strstarts(str(?inputfile), 'data/')) .

  ?plan renku:hasOutputs ?output .
  ?output schema:defaultValue ?outputfile .
  # get the ending time to sort the entities chronologically
  ?act prov:endedAtTime ?ended .
  
} limit 10


####### variation to add parameters

PREFIX schema: <http://schema.org/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX renku: <https://swissdatasciencecenter.github.io/renku-ontology#>

SELECT DISTINCT ?argument ?gen ?plan ?act ?kw ?ended ?inputfile ?outputfile WHERE {

  # get the generation for the activity, and descend into
  # the keywords to identify the project that generated it
  ?gen prov:activity ?act .
  ?entity prov:qualifiedGeneration ?gen .
  ?files prov:entity ?entity .
  ?dataset schema:hasPart ?files .
  ?dataset schema:keywords ?kw .

  ?act a prov:Activity .
  ?act prov:qualifiedAssociation ?asoc.
  ?asoc prov:hadPlan ?plan .
  ?plan renku:hasInputs ?input .
  ?input schema:defaultValue ?inputfile .

  # handy heuristic: we do not care about src/*
  FILTER (strstarts(str(?inputfile), 'data/')) .

  ?plan renku:hasOutputs ?output .
  ?output schema:defaultValue ?outputfile .
  # get the ending time to sort the entities chronologically
  ?act prov:endedAtTime ?ended .

  ?plan renku:hasArguments ?args .
  ?args schema:defaultValue ?argument .
  
} limit 10


####### variation to add parameters and parameters mappings

PREFIX schema: <http://schema.org/>
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX prov: <http://www.w3.org/ns/prov#>
PREFIX renku: <https://swissdatasciencecenter.github.io/renku-ontology#>

SELECT DISTINCT ?asoc ?argument ?gen ?plan ?act ?kw ?ended ?inputfile ?outputfile WHERE {

  # get the generation for the activity, and descend into
  # the keywords to identify the project that generated it
  ?gen prov:activity ?act .
  ?entity prov:qualifiedGeneration ?gen .
  ?files prov:entity ?entity .
  ?dataset schema:hasPart ?files .
  ?dataset schema:keywords ?kw .

  ?act a prov:Activity .
  ?act prov:qualifiedAssociation ?asoc.
  ?asoc prov:hadPlan ?plan .
  ?plan renku:hasInputs ?input .
  ?input schema:defaultValue ?inputfile .

  # handy heuristic: we do not care about src/*
  FILTER (strstarts(str(?inputfile), 'data/')) .

  ?plan renku:hasOutputs ?output .
  ?output schema:defaultValue ?outputfile .
  # get the ending time to sort the entities chronologically
  ?act prov:endedAtTime ?ended .

  ?plan renku:hasArguments ?args .
  ?args schema:defaultValue ?argument .

} limit 10


## what is the name of the argument above? no way to know unless using compositeplans...



# anyway,

# https://github.com/SwissDataScienceCenter/renku-graph/blob/51f4425c8f3abaa09fef6dab74013baf7ceafedb/knowledge-graph/src/main/scala/io/renku/knowledgegraph/datasets/DatasetsFinder.scala#L107

# the API https://github.com/SwissDataScienceCenter/renku-graph/tree/51f4425c8f3abaa09fef6dab74013baf7ceafedb/knowledge-graph



SELECT ?identifier ?name ?slug ?maybeDescription ?maybeDatePublished ?maybeDateCreated ?date 
?maybeDerivedFrom ?sameAs (SAMPLE(?projectSlug) AS ?projectSampleSlug) ?projectsCount
(GROUP_CONCAT(?keyword; separator='') AS ?keywords)
(GROUP_CONCAT(?encodedImageUrl; separator='') AS ?images) 
WHERE { 
  { 
    SELECT ?sameAs (COUNT(DISTINCT ?projectId) AS ?projectsCount) 
    (SAMPLE(?dsId) AS ?dsIdSample) (SAMPLE(?projectId) AS ?projectIdSample) 
    WHERE { 
      { 
        SELECT ?sameAs ?projectId ?dsId 
        (GROUP_CONCAT(DISTINCT ?childProjectId; separator='') AS ?childProjectsIds) 
        (GROUP_CONCAT(DISTINCT ?projectIdWhereInvalidated; separator='') AS ?projectsIdsWhereInvalidated)
        WHERE {
          {
            SELECT DISTINCT ?projectId ?id
            WHERE { ?id text:query (schema:name schema:description renku:slug schema:keywords '$phrase') }
          } {
            GRAPH ?projectId {
              ?id a schema:Dataset
            }
            BIND(?id AS ?dsId)
          } UNION {
            GRAPH almut.luetg {
              ?id a schema:Person
            }
            GRAPH ?projectId {
              ?dsId schema:creator ?id;
                    a schema:Dataset
            }
          }
          GRAPH ?projectId {
            ?dsId renku:topmostSameAs ?sameAs;
                  ^renku:hasDataset ?projectId.
            ${projectMemberFilterQuery(maybeUser)}
            OPTIONAL {
              ?childDsId prov:wasDerivedFrom/schema:url ?dsId;
                         ^renku:hasDataset ?childProjectId.
            }
            OPTIONAL {
              ?dsId prov:invalidatedAtTime ?invalidationTime;
                    ^renku:hasDataset ?projectIdWhereInvalidated
            }
          }
        }
        GROUP BY ?sameAs ?projectId ?dsId
      }
      FILTER (IF (BOUND(?childProjectsIds), !CONTAINS(STR(?childProjectsIds), STR(?projectId)), true))
      FILTER (IF (BOUND(?projectsIdsWhereInvalidated), !CONTAINS(STR(?projectsIdsWhereInvalidated), STR(?projectId)), true))
    }
    GROUP BY ?sameAs 
  }
  GRAPH ?projectIdSample {
    ?dsIdSample renku:topmostSameAs ?sameAs;
                schema:identifier ?identifier;
                schema:name ?name;
                renku:slug ?slug. 
    ?projectIdSample renku:projectPath ?projectSlug.
    OPTIONAL {
      ?dsIdSample schema:image ?imageId.
      ?imageId schema:position ?imagePosition;
               schema:contentUrl ?imageUrl.
      BIND (CONCAT(STR(?imagePosition), STR(':'), STR(?imageUrl)) AS ?encodedImageUrl)
    }
    OPTIONAL { ?dsIdSample schema:keywords ?keyword }
    OPTIONAL { ?dsIdSample schema:description ?maybeDescription }
    OPTIONAL { ?dsIdSample prov:wasDerivedFrom/schema:url ?maybeDerivedFrom }
    OPTIONAL {
      ?dsIdSample schema:dateCreated ?maybeDateCreated.
      BIND (?maybeDateCreated AS ?date)
    }
    OPTIONAL {
      ?dsIdSample schema:datePublished ?maybeDatePublished
      BIND (?maybeDatePublished AS ?date)
    }
  }
}
GROUP BY ?identifier ?name ?slug ?maybeDescription ?maybeDatePublished ?maybeDateCreated ?date
?maybeDerivedFrom ?sameAs ?projectsCount
